Line #    Mem usage    Increment   Line Contents
================================================
   159  656.848 MiB    0.000 MiB   @profile
   160                             def cqt_single(signal, sample_freq, channels=1):
   161                                 ''' 
   162                                 Compute the CQT of a signal with a single loop
   163                                 '''
   164  656.848 MiB    0.000 MiB       max_width = int(1/(.03*100)*sample_freq)
   165  656.848 MiB    0.000 MiB       frequency_range = 100.*2.**(1./(12. * channels)*np.array(range(0, 50)))
   166  656.863 MiB    0.016 MiB       time_list = range(0, int(len(signal) - max_width), int(max_width/2))
   167  657.727 MiB    0.863 MiB       output = np.zeros((len(time_list), len(frequency_range)))
   168  667.156 MiB    9.430 MiB       kernel, max_width = pre_compute_kernels(sample_freq, frequency_range, max_width, "kernel")
   169  667.156 MiB    0.000 MiB       prior = resource.getrusage(resource.RUSAGE_SELF)
   170  919.277 MiB  252.121 MiB       n_sig = np.ones((len(time_list) , max_width))
   171  941.715 MiB   22.438 MiB       for l_1, t in enumerate(time_list):
   172  941.715 MiB    0.000 MiB           output[l_1] = np.sum(signal[t:t + max_width] * kernel, axis=1)
   173                                 # output = n_sig.dot(np.asarray(kernel).transpose())
   174  941.461 MiB   -0.254 MiB       post = resource.getrusage(resource.RUSAGE_SELF)
   175  941.461 MiB    0.000 MiB       user_time = post.ru_utime - prior.ru_utime
   176  941.461 MiB    0.000 MiB       print("System time for single loop computation: " + str(post.ru_stime - prior.ru_stime))
   177  941.461 MiB    0.000 MiB       print("User time for single loop computation: " + str(post.ru_utime - prior.ru_utime))
   178                             
   179  941.461 MiB    0.000 MiB       return output, user_time


Filename: compute_stfts.py

Line #    Mem usage    Increment   Line Contents
================================================
   180  317.090 MiB    0.000 MiB   @profile
   181                             def matrix_cqt(signal, sample_freq, channels=1):
   182                                 '''
   183                                 Direct computation of CQT using numpy.
   184                                 The signal matrix is constructed by advanced indexing of the
   185                                 signal vector. The CQT is the dot product of signal with the transpose of the kernel
   186                                 matrix.
   187                                 '''
   188                             
   189  317.090 MiB    0.000 MiB       max_width = int(1/(.03*100)*sample_freq)
   190  317.090 MiB    0.000 MiB       frequency_range = 100.*2.**(1./(12. * channels)*np.array(range(0, 50)))
   191  317.090 MiB    0.000 MiB       time_list = range(0, int(len(signal) - max_width), int(max_width/2))
   192  317.090 MiB    0.000 MiB       output = np.zeros((len(time_list), len(frequency_range)))
   193  318.219 MiB    1.129 MiB       kernel, max_width = pre_compute_kernels(sample_freq, frequency_range, max_width, "kernel")
   194  318.219 MiB    0.000 MiB       h = int(max_width/2)
   195  318.219 MiB    0.000 MiB       n = time_list[-1] + h
   196  318.219 MiB    0.000 MiB       col_index = np.arange(0, n, h)
   197  318.219 MiB    0.000 MiB       row_index = np.arange(max_width)
   198  570.340 MiB  252.121 MiB       index = col_index[:,np.newaxis] + row_index[np.newaxis, :]
   199  570.340 MiB    0.000 MiB       prior = resource.getrusage(resource.RUSAGE_SELF)
   200  822.461 MiB  252.121 MiB       sliced_signal = signal[index]
   201  836.938 MiB   14.477 MiB       output = sliced_signal.dot(np.asarray(kernel).transpose())
   202  836.332 MiB   -0.605 MiB       post = resource.getrusage(resource.RUSAGE_SELF)
   203  836.340 MiB    0.008 MiB       user_time = post.ru_utime - prior.ru_utime
   204  836.340 MiB    0.000 MiB       print("System time for direct computation : " + str(post.ru_stime - prior.ru_stime))
   205  836.340 MiB    0.000 MiB       print("User time for direct computation : " + str(post.ru_utime - prior.ru_utime))
   206  836.340 MiB    0.000 MiB       return output, user_time


Filename: compute_stfts.py

Line #    Mem usage    Increment   Line Contents
================================================
   235  304.914 MiB    0.000 MiB   @profile
   236                             def vectorized_theano(signal, sample_freq, channels=1):
   237                                 '''
   238                                 The Code is currently being tested. It's not fully implemented.
   239                                 It's being tested with memory and speed.
   240                                 '''
   241  304.922 MiB    0.008 MiB       max_width = int(1/(.03*100)*sample_freq)
   242  304.922 MiB    0.000 MiB       frequency_range = 100.*2.**(1./(12. * channels)*np.array(range(0, 50)))
   243  304.922 MiB    0.000 MiB       time_list = range(0, int(len(signal) - max_width), int(max_width/2))
   244  304.922 MiB    0.000 MiB       signal_matrix = T.fvector("signal_matrix")
   245  304.922 MiB    0.000 MiB       kernel_matrix = T.fmatrix("kernel matrix")
   246  314.449 MiB    9.527 MiB       kernel, k_size = pre_compute_kernels(sample_freq, frequency_range, max_width)
   247  315.312 MiB    0.863 MiB       output = np.zeros((len(time_list), len(frequency_range)))
   248  315.312 MiB    0.000 MiB       prior = resource.getrusage(resource.RUSAGE_SELF)
   249  315.324 MiB    0.012 MiB       cqt_compute = kernel_matrix * signal_matrix
   250  315.438 MiB    0.113 MiB       func = theano.function([kernel_matrix, signal_matrix], cqt_compute, allow_input_downcast=True)
   251  321.047 MiB    5.609 MiB       for l_1, t in enumerate(time_list):
   252  321.047 MiB    0.000 MiB           n_signal = signal[l_1:l_1 + k_size]
   253  321.047 MiB    0.000 MiB           output[l_1] = np.sum(func(kernel, n_signal), axis=1)
   254  321.047 MiB    0.000 MiB       post = resource.getrusage(resource.RUSAGE_SELF)
   255  321.047 MiB    0.000 MiB       user_time = post.ru_utime - prior.ru_utime
   256  321.047 MiB    0.000 MiB       print("System time for vectorized theano : " + str(post.ru_stime - prior.ru_stime))
   257  321.047 MiB    0.000 MiB       print("User time for vectorized theano: " + str(post.ru_utime - prior.ru_utime))
   258  321.047 MiB    0.000 MiB       return output, user_time


Filename: compute_stfts.py

Line #    Mem usage    Increment   Line Contents
================================================
   260  306.285 MiB    0.000 MiB   @profile
   261                             def matrix_theano(signal, sample_freq, channels=1):
   262                                 '''
   263                                 Direct computation of CQT without any loop using theano
   264                                 '''
   265                             
   266  306.293 MiB    0.008 MiB       max_width = int(1/(.03*100)*sample_freq)
   267  306.293 MiB    0.000 MiB       frequency_range = 100.*2.**(1./(12. * channels)*np.array(range(0, 50)))
   268  306.293 MiB    0.000 MiB       time_list = range(0, int(len(signal) - max_width), int(max_width/2))
   269  306.293 MiB    0.000 MiB       signal_matrix = T.fmatrix("Signal Matrix")
   270  306.293 MiB    0.000 MiB       kernel_matrix = T.fmatrix("Kernel Matrix")
   271  316.680 MiB   10.387 MiB       kernel, k_size = pre_compute_kernels(sample_freq, frequency_range, max_width)
   272  316.684 MiB    0.004 MiB       h = int(max_width/2)
   273  316.684 MiB    0.000 MiB       n = time_list[-1] + h
   274  316.684 MiB    0.000 MiB       col_index = np.arange(0, n, h)
   275  316.684 MiB    0.000 MiB       row_index = np.arange(max_width)
   276  568.805 MiB  252.121 MiB       index = col_index[:,np.newaxis] + row_index[np.newaxis, :]
   277  568.805 MiB    0.000 MiB       prior = resource.getrusage(resource.RUSAGE_SELF)
   278  820.926 MiB  252.121 MiB       sliced_signal = signal[index]
   279  820.930 MiB    0.004 MiB       cqt_compute = T.dot(signal_matrix, kernel_matrix.T)
   280  821.074 MiB    0.145 MiB       func = theano.function([signal_matrix, kernel_matrix], cqt_compute, allow_input_downcast=True)
   281  952.152 MiB  131.078 MiB       output = func(sliced_signal, kernel)
   282  952.152 MiB    0.000 MiB       post = resource.getrusage(resource.RUSAGE_SELF)
   283  952.152 MiB    0.000 MiB       user_time = post.ru_utime - prior.ru_utime
   284  952.152 MiB    0.000 MiB       print("System time for matrix theano: " + str(post.ru_stime - prior.ru_stime))
   285  952.152 MiB    0.000 MiB       print("User time for matrix theano: " + str(post.ru_utime - prior.ru_utime))
   286  952.152 MiB    0.000 MiB       return output, user_time

